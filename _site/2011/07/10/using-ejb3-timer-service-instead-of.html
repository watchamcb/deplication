<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Using the EJB3 timer service instead of Thread.sleep() | Your awesome title</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Using the EJB3 timer service instead of Thread.sleep()" />
<meta name="author" content="Craig Watcham" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="As with most software development a large amount of effort is spent testing, be it functional or regression. The effort required to coordinate testing increases significantly when integration with external systems is required, particularly if those systems are not part of the same division or organisation. I recently volunteered to assist with reducing this overhead for an interface to our payment gateway, this post uses this implementation to demonstrate the use of the EJB 3 timer service for delaying processing." />
<meta property="og:description" content="As with most software development a large amount of effort is spent testing, be it functional or regression. The effort required to coordinate testing increases significantly when integration with external systems is required, particularly if those systems are not part of the same division or organisation. I recently volunteered to assist with reducing this overhead for an interface to our payment gateway, this post uses this implementation to demonstrate the use of the EJB 3 timer service for delaying processing." />
<link rel="canonical" href="http://localhost:4000/2011/07/10/using-ejb3-timer-service-instead-of.html" />
<meta property="og:url" content="http://localhost:4000/2011/07/10/using-ejb3-timer-service-instead-of.html" />
<meta property="og:site_name" content="Your awesome title" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-07-10T18:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Using the EJB3 timer service instead of Thread.sleep()" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Craig Watcham"},"dateModified":"2011-07-10T18:00:00+01:00","datePublished":"2011-07-10T18:00:00+01:00","description":"As with most software development a large amount of effort is spent testing, be it functional or regression. The effort required to coordinate testing increases significantly when integration with external systems is required, particularly if those systems are not part of the same division or organisation. I recently volunteered to assist with reducing this overhead for an interface to our payment gateway, this post uses this implementation to demonstrate the use of the EJB 3 timer service for delaying processing.","headline":"Using the EJB3 timer service instead of Thread.sleep()","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2011/07/10/using-ejb3-timer-service-instead-of.html"},"url":"http://localhost:4000/2011/07/10/using-ejb3-timer-service-instead-of.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@latest/css/all.min.css">
  <link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Your awesome title" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Your awesome title</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Using the EJB3 timer service instead of Thread.sleep()</h1>
    <p class="post-meta"><time class="dt-published" datetime="2011-07-10T18:00:00+01:00" itemprop="datePublished">
        Jul 10, 2011
      </time>â€¢ 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Craig Watcham</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    As with most software development a large amount of effort is spent testing, be it functional or regression. The effort required to coordinate testing increases significantly when integration with external systems is required, particularly if those systems are not part of the same division or organisation. I recently volunteered to assist with reducing this overhead for an interface to our payment gateway, this post uses this implementation to demonstrate the use of the EJB 3 timer service for delaying processing.<br />


The gateway in this system is responsible for routing messages to a payment network and processing asynchronous responses which are then communicated to the originating source system. In this case the source system interface to the gateway is quite simple, using TextMessage objects placed on a JMS queue hosted on JBoss. The response messages from the gateway are simple ACK/NACK messages containing an identifier and are placed on a separate JMS response queue processed by the source system. Unfortunately the test payment network is not always available and is only able to accept payment messages to specific test entities, this limits the variety of test cases and introduces reliability issues in the regression testing. Given the simple interface mechanism it was logical to create a gateway simulator that merely processed the request queue and sent corresponding responses to the response queue. The original implementation code as as follows:<br />
<br />
<pre class="brush: java">@MessageDriven(activationConfig = {
  @ActivationConfigProperty(propertyName = "destinationType", 
    propertyValue = "javax.jms.Queue"),
  @ActivationConfigProperty(propertyName = "destination", 
    propertyValue = "queue/InQueue")
  //...
  })
@TransactionManagement(value = TransactionManagementType.CONTAINER)
@TransactionAttribute(TransactionAttributeType.REQUIRED)
public class SimulateGatewayMDB implements MessageListener {
    static Logger log = Logger.getLogger(SimulateGatewayMDB.class);

    @Resource(mappedName = "ConnectionFactory")
    private QueueConnectionFactory connectionFactory;

    @Resource(mappedName = "queue/OutQueue")
    private Queue responseQueue;

    public void onMessage(Message message) {
        try {
            String reference = message.getStringProperty("Reference");
            log.info("Simulator received message: " + reference);
            queueReply(reference);
        } catch (Exception e) {
            log.error("Message processing failed.", e);
        }
    }

    protected void queueReply(String sourceReference) throws Exception {
        final String SEPARATOR = ";";
        StringBuffer message = new StringBuffer("GWRESPONSE");
        message.append(SEPARATOR);
        message.append(sourceReference).append(SEPARATOR);
        message.append("ACK").append(SEPARATOR);
        message.append("ACK by SimulateGW").append(SEPARATOR);
        message.append("Response").append(SEPARATOR);
        publishMessage(message.toString());
    }

    private void publishMessage(String message) throws Exception {
        QueueConnection queueConnection =
            connectionFactory.createQueueConnection();
        QueueSession queueSession = queueConnection.createQueueSession(false, 
            Session.AUTO_ACKNOWLEDGE);
        TextMessage textMessage = queueSession.createTextMessage(message);
        QueueSender sender = queueSession.createSender(responseQueue);
        sender.send(textMessage);
        queueConnection.close();
    }
}
</pre><br />
This implementation works exactly as expected, placing a response message on the response queue for each request message. Unfortunately it works a bit too well... In the production environment the message is sent to an external network and has a delay between the request being sent and the response being received (hence the asynchronous processing). This delay allows the source system to perform additional processing, updating the message status and moving it along a workflow. The almost instantaneous response from the simulator prevents this processing from occurring which causes some of the test cases to fail.<br />
<br />
The obvious solution to this timing issue is to introduce an artificial delay between the request being received and the response being sent. In a standalone application this delay would typically be accomplished by calling Thread.sleep() to delay further processing. The EJB specification is quite clear about not interfering with the container thread management: <br />
<br />
<blockquote>"The enterprise bean must not attempt to manage threads. The enterprise bean must not attempt to start, stop, suspend, or resume a thread, or to change a threadâ€™s priority or name. The enterprise bean must not attempt to manage thread groups.<br />
<br />
These functions are reserved for the EJB container. Allowing the enterprise bean to manage threads would decrease the containerâ€™s ability to properly manage the runtime environment."</blockquote><br />
It is unclear whether or not Thread.sleep() should be considered a thread management attempt but  it is preferable to use the container provided timer service. Fortunately this service is remarkably simple to use:<br />
<ul><li>Add a&nbsp;TimerService resource</li>
<li>Add a&nbsp;@Timeout annotated method as a callback on timer expiry</li>
</ul>The updated code (containing the changed sections):<br />
<br />
<pre class="brush: java">    @Resource
    javax.ejb.TimerService timerService;

    public void onMessage(Message message) {
        try {
            String reference = message.getStringProperty("Reference");
            log.info("Simulator received message: " + reference);
            timerService.createTimer(10000, reference);
        } catch (Exception e) {
            log.error("Message processing failed.", e);
        }
    }

    @Timeout
    public void sendResponse(Timer timer) {
        try {
            log.info("Sending response: " + timer.getInfo());
            queueReply((String) timer.getInfo());
        } catch (Exception e) {
            log.error("Message processing failed.", e);
        }
    }
</pre><br />
The changes above introduce a ten second delay between the request being received and the response being sent. A few notes about the implementation:<br />
<br />
<ul><li>The createTimer call creates a single action timer which is only triggered once when the specified period (in milliseconds) &nbsp;has passed.</li>
<li>The reference object passed into the createTimer method is a string but can be replaced with any class implementing the Serializable interface</li>
<li>There are various other methods serving different purposes which are provided by the TimerService interface</li>
</ul><br />
Andrew Lee Rubinger and Bill Burke's book <a href="http://oreilly.com/catalog/9780596158033/">Enterprise JavaBeans 3.1</a> is an excellent resource for EJB3 implementation. Additional credit to <a href="http://oreilly.com/">O'Reilly</a> for providing quality book downloads in a number of DRM-free formats. Thanks to Alex Gorbatchev's <a href="http://alexgorbatchev.com/SyntaxHighlighter/">SyntaxHighlighter</a> for providing the code formatting script embedded in this page.
  </div><a class="u-url" href="/2011/07/10/using-ejb3-timer-service-instead-of.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="http://localhost:4000/feed.xml">
            <svg class="svg-icon orange">
              <path d="M12.8 16C12.8 8.978 7.022 3.2 0 3.2V0c8.777 0 16 7.223 16 16h-3.2zM2.194
                11.61c1.21 0 2.195.985 2.195 2.196 0 1.21-.99 2.194-2.2 2.194C.98 16 0 15.017 0
                13.806c0-1.21.983-2.195 2.194-2.195zM10.606
                16h-3.11c0-4.113-3.383-7.497-7.496-7.497v-3.11c5.818 0 10.606 4.79 10.606 10.607z"
              />
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">GitHub User</li>
          <li><a class="u-email" href="mailto:your-email@domain.com">your-email@domain.com</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"></ul>
</div>

  </div>

</footer>
</body>

</html>
