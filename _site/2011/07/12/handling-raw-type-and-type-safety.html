<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Handling raw type and type safety warnings when using legacy code | Deplication</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Handling raw type and type safety warnings when using legacy code" />
<meta name="author" content="Craig Watcham" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The addition of generics to Java 5 enabled type checking at compile time. This assists in preventing a ClassCastException at runtime but to maintain backward compatibility generics also came with Type Erasure: Type erasure exists so that new code may continue to interface with legacy code. Using a raw type for any other reason is considered bad programming practice and should be avoided whenever possible. When mixing legacy code with generic code, you may encounter warning messages similar to the following: Note: WarningDemo.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Unfortunately for projects with large legacy code bases or dependencies on legacy third party libraries the raw type warnings can be a major irritation if you prefer not to have false-positive warnings. The solution is to add the @SuppressWarnings(“rawtypes”) annotation which works as expected, telling the compiler to ignore the raw type issue. The problem with this approach (as discussed elsewhere) is that your code ends up having an annotation for each call to the legacy code which in turn reduces readability. Adding @SuppressWarnings({ “unchecked”, “rawtypes” }) at the class level will also suppress all the warnings but may unintentionally mask instances that should be flagged as warnings. An alternative approach is provided below. Lets assume that you have a legacy code method (which you are not able to change) as defined below: /** * Retrieve the list of values * @return A vector of string values */ public static Vector getValues(); In your code you would like to use generics to process the returned vector as below: public static void main(String[] args) { Vector&lt;String&gt; safeVector = getValues(); for (String value : safeVector) { System.out.println(value); } } Compiling your code gives the “uses unchecked or unsafe operations” warning. Rather than adding the suppress warnings to every line where getValues() is being called you can instead define a wrapper method returning the typed vector as below: @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public static &lt;T&gt; Vector&lt;T&gt; castType(Vector v) { return (Vector&lt;T&gt;) v; } This means your code is changed as follows: public static void main(String[] args) { Vector&lt;String&gt; safeVector = castType(getValues()); for (String value : safeVector) { System.out.println(value); } } The warning messages are no longer a problem and the code functions as expected. A few notes on the implementation: The type T is inferred from the Vector&lt;String&gt; declaration, the castType method would work equally well for an integer vector (Vector&lt;Integer&gt;) . The warning is merely being suppressed, the castType method is not actually checking the type of the vector elements. A runtime exception will occur when accessing an element if the vector passed to the method is not actually of the declared type. The castType method should only be used when you are certain of the type of elements contained in the vector (restating the above point). The castType implementation is using vectors to demonstrate the concept but can be extended to other types (or even generalised to use the Collection interface) An argument can be made against the overhead of castType method call instead of a class level @SuppressWarnings annotation, this implementation merely provides an alternative. For completeness the generalised method would look as follows: @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public static &lt;T&gt; Collection&lt;T&gt; castType(Collection v) { return (Collection&lt;T&gt;) v; }" />
<meta property="og:description" content="The addition of generics to Java 5 enabled type checking at compile time. This assists in preventing a ClassCastException at runtime but to maintain backward compatibility generics also came with Type Erasure: Type erasure exists so that new code may continue to interface with legacy code. Using a raw type for any other reason is considered bad programming practice and should be avoided whenever possible. When mixing legacy code with generic code, you may encounter warning messages similar to the following: Note: WarningDemo.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Unfortunately for projects with large legacy code bases or dependencies on legacy third party libraries the raw type warnings can be a major irritation if you prefer not to have false-positive warnings. The solution is to add the @SuppressWarnings(“rawtypes”) annotation which works as expected, telling the compiler to ignore the raw type issue. The problem with this approach (as discussed elsewhere) is that your code ends up having an annotation for each call to the legacy code which in turn reduces readability. Adding @SuppressWarnings({ “unchecked”, “rawtypes” }) at the class level will also suppress all the warnings but may unintentionally mask instances that should be flagged as warnings. An alternative approach is provided below. Lets assume that you have a legacy code method (which you are not able to change) as defined below: /** * Retrieve the list of values * @return A vector of string values */ public static Vector getValues(); In your code you would like to use generics to process the returned vector as below: public static void main(String[] args) { Vector&lt;String&gt; safeVector = getValues(); for (String value : safeVector) { System.out.println(value); } } Compiling your code gives the “uses unchecked or unsafe operations” warning. Rather than adding the suppress warnings to every line where getValues() is being called you can instead define a wrapper method returning the typed vector as below: @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public static &lt;T&gt; Vector&lt;T&gt; castType(Vector v) { return (Vector&lt;T&gt;) v; } This means your code is changed as follows: public static void main(String[] args) { Vector&lt;String&gt; safeVector = castType(getValues()); for (String value : safeVector) { System.out.println(value); } } The warning messages are no longer a problem and the code functions as expected. A few notes on the implementation: The type T is inferred from the Vector&lt;String&gt; declaration, the castType method would work equally well for an integer vector (Vector&lt;Integer&gt;) . The warning is merely being suppressed, the castType method is not actually checking the type of the vector elements. A runtime exception will occur when accessing an element if the vector passed to the method is not actually of the declared type. The castType method should only be used when you are certain of the type of elements contained in the vector (restating the above point). The castType implementation is using vectors to demonstrate the concept but can be extended to other types (or even generalised to use the Collection interface) An argument can be made against the overhead of castType method call instead of a class level @SuppressWarnings annotation, this implementation merely provides an alternative. For completeness the generalised method would look as follows: @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public static &lt;T&gt; Collection&lt;T&gt; castType(Collection v) { return (Collection&lt;T&gt;) v; }" />
<link rel="canonical" href="http://localhost:4000/2011/07/12/handling-raw-type-and-type-safety.html" />
<meta property="og:url" content="http://localhost:4000/2011/07/12/handling-raw-type-and-type-safety.html" />
<meta property="og:site_name" content="Deplication" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-07-12T12:38:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Handling raw type and type safety warnings when using legacy code" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Craig Watcham"},"dateModified":"2011-07-12T12:38:00+01:00","datePublished":"2011-07-12T12:38:00+01:00","description":"The addition of generics to Java 5 enabled type checking at compile time. This assists in preventing a ClassCastException at runtime but to maintain backward compatibility generics also came with Type Erasure: Type erasure exists so that new code may continue to interface with legacy code. Using a raw type for any other reason is considered bad programming practice and should be avoided whenever possible. When mixing legacy code with generic code, you may encounter warning messages similar to the following: Note: WarningDemo.java uses unchecked or unsafe operations. Note: Recompile with -Xlint:unchecked for details. Unfortunately for projects with large legacy code bases or dependencies on legacy third party libraries the raw type warnings can be a major irritation if you prefer not to have false-positive warnings. The solution is to add the @SuppressWarnings(“rawtypes”) annotation which works as expected, telling the compiler to ignore the raw type issue. The problem with this approach (as discussed elsewhere) is that your code ends up having an annotation for each call to the legacy code which in turn reduces readability. Adding @SuppressWarnings({ “unchecked”, “rawtypes” }) at the class level will also suppress all the warnings but may unintentionally mask instances that should be flagged as warnings. An alternative approach is provided below. Lets assume that you have a legacy code method (which you are not able to change) as defined below: /** * Retrieve the list of values * @return A vector of string values */ public static Vector getValues(); In your code you would like to use generics to process the returned vector as below: public static void main(String[] args) { Vector&lt;String&gt; safeVector = getValues(); for (String value : safeVector) { System.out.println(value); } } Compiling your code gives the “uses unchecked or unsafe operations” warning. Rather than adding the suppress warnings to every line where getValues() is being called you can instead define a wrapper method returning the typed vector as below: @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public static &lt;T&gt; Vector&lt;T&gt; castType(Vector v) { return (Vector&lt;T&gt;) v; } This means your code is changed as follows: public static void main(String[] args) { Vector&lt;String&gt; safeVector = castType(getValues()); for (String value : safeVector) { System.out.println(value); } } The warning messages are no longer a problem and the code functions as expected. A few notes on the implementation: The type T is inferred from the Vector&lt;String&gt; declaration, the castType method would work equally well for an integer vector (Vector&lt;Integer&gt;) . The warning is merely being suppressed, the castType method is not actually checking the type of the vector elements. A runtime exception will occur when accessing an element if the vector passed to the method is not actually of the declared type. The castType method should only be used when you are certain of the type of elements contained in the vector (restating the above point). The castType implementation is using vectors to demonstrate the concept but can be extended to other types (or even generalised to use the Collection interface) An argument can be made against the overhead of castType method call instead of a class level @SuppressWarnings annotation, this implementation merely provides an alternative. For completeness the generalised method would look as follows: @SuppressWarnings({ &quot;unchecked&quot;, &quot;rawtypes&quot; }) public static &lt;T&gt; Collection&lt;T&gt; castType(Collection v) { return (Collection&lt;T&gt;) v; }","headline":"Handling raw type and type safety warnings when using legacy code","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2011/07/12/handling-raw-type-and-type-safety.html"},"url":"http://localhost:4000/2011/07/12/handling-raw-type-and-type-safety.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Deplication" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Deplication</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Handling raw type and type safety warnings when using legacy code</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2011-07-12T12:38:00+01:00" itemprop="datePublished">Jul 12, 2011
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Craig Watcham</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    The addition of generics to Java 5 enabled type checking at compile time. This assists in preventing a ClassCastException at runtime but to maintain backward compatibility generics also came with <a href="http://download.oracle.com/javase/tutorial/java/generics/erasure.html%22">Type Erasure</a>:<br />
<blockquote>Type erasure exists so that new code may continue to interface with legacy code. Using a raw type for any other reason is considered bad programming practice and should be avoided whenever possible.<br />
<br />
When mixing legacy code with generic code, you may encounter warning messages similar to the following:<br />
<br />
Note: WarningDemo.java uses unchecked or unsafe operations.<br />
Note: Recompile with -Xlint:unchecked for details.</blockquote><br />
Unfortunately for projects with large legacy code bases or dependencies on legacy third party libraries the raw type warnings can be a major irritation if you prefer not to have false-positive warnings. The solution is to add the @SuppressWarnings("rawtypes") annotation which works as expected, telling the compiler to ignore the raw type issue. The problem with this approach (as <a href="http://stackoverflow.com/questions/1130433/how-to-avoid-unchecked-conversion-warning-in-java-if-you-use-legacy-libraries">discussed</a> elsewhere) is that your code ends up having an annotation for each call to the legacy code which in turn reduces readability. Adding @SuppressWarnings({ "unchecked", "rawtypes" }) at the class level will also suppress all the warnings but may unintentionally mask instances that should be flagged as warnings. An alternative approach is provided below.<br />
<br />
Lets assume that you have a legacy code method (which you are not able to change) as defined below:<br />
<pre class="brush: java">/**
     * Retrieve the list of values
     * @return A vector of string values
     */
    public static Vector getValues();
</pre><br />
In your code you would like to use generics to process the returned vector as below:<br />
<pre class="brush: java">public static void main(String[] args) {
        Vector&lt;String&gt; safeVector = getValues();
        for (String value : safeVector) {
            System.out.println(value);
        }
    }
</pre><br />
Compiling your code gives the "uses unchecked or unsafe operations" warning. Rather than adding the suppress warnings to every line where getValues() is being called you can instead define a wrapper method returning the typed vector as below:<br />
<pre class="brush: java">@SuppressWarnings({ "unchecked", "rawtypes" })
    public static &lt;T&gt; Vector&lt;T&gt; castType(Vector v) {
        return (Vector&lt;T&gt;) v;        
    }
</pre><br />
This means your code is changed as follows:<br />
<pre class="brush: java">public static void main(String[] args) {
        Vector&lt;String&gt; safeVector = castType(getValues());
        for (String value : safeVector) {
            System.out.println(value);
        }
    }
</pre><br />
The warning messages are no longer a problem and the code functions as expected. A few notes on the implementation:<br />
<br />
<ul><li>The type T is inferred from the Vector&lt;String&gt; declaration, the castType method would work equally well for an integer vector (Vector&lt;Integer&gt;) .</li>
<li>The warning is merely being suppressed, the castType method is not actually checking the type of the vector elements. A runtime exception will occur when accessing an element if the vector passed to the method is not actually of the declared type.</li>
<li>The castType method should only be used when you are certain of the type of elements contained in the vector (restating the above point).</li>
<li>The castType implementation is using vectors to demonstrate the concept but can be extended to other types (or even generalised to use the Collection interface)</li>
<li>An argument can be made against the overhead of castType method call instead of a class level @SuppressWarnings annotation, this implementation merely provides an alternative.</li>
</ul><br />
For completeness the generalised method would look as follows:<br />
<pre class="brush: java">@SuppressWarnings({ "unchecked", "rawtypes" })
    public static &lt;T&gt; Collection&lt;T&gt; castType(Collection v) {
        return (Collection&lt;T&gt;) v;        
    }
</pre>
  </div><a class="u-url" href="/2011/07/12/handling-raw-type-and-type-safety.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Deplication</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Deplication</li><li><a class="u-email" href="mailto:craig@deplication.net">craig@deplication.net</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/watchamcb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">watchamcb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Simpler is better.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
