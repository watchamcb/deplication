<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Missing the A in Asynchronous - Part 1 | Deplication</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Missing the A in Asynchronous - Part 1" />
<meta name="author" content="Craig Watcham" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Few things are more irritating in software development than when people use a kludge rather than taking the time to implement a properly designed and robust solution. The peeve I am exercising today relates to the code snippet that follows:     private BOTransfer getTransferInefficiently(Trade trade) throws RemoteException {   // There is some delay between when a trade and corresponsing transfer is created   BOTransfer transfer = null; int cnt = 0; do {            try { Thread.sleep(500l);           } catch (Exception e) { return null;           }           transfer = getFirstTransfer(trade); } while (cnt++ &lt; 10 &amp;&amp; transfer == null); return transfer;     } The code is pretty simple. Wait 500ms and try and load a transfer object from the trade, repeat until the transfer object is loaded or the number of load attempts reaches 10. In a single threaded or single user environment this code might be excusable. In a multi-user production trading system processing hundreds of transactions a second this implementation is totally unacceptable. Some well meaning soul has added a comment further explaining the method: &nbsp; &nbsp; // This implementation is fundamentally broken in many ways. The transfer creation is &nbsp; &nbsp; // asynchronous and this logic should be triggered off the transfer creation event (instead of &nbsp; &nbsp; // looping and sleeping). This approach prevents this engine thread from processing any other &nbsp; &nbsp; // events and will not find the transfer in the case where the TransferEngine is under heavy &nbsp; &nbsp; // load. useInefficientWaitForTransfer method added to the interface to allow correct &nbsp; &nbsp; // implementation on new classes This person at least understood that the code was a problem and tried to mitigate the risks by extracting it into a separate method and adding the explanatory comment. Unfortunately for whatever reason (time constraints, lack of automated regression testing, indifference, ...) they only raised the visibility of the problem rather than fixing it entirely. Issues Increased system load - the call to getFirstTransfer actually does a remote call and a database query each time it is executed. This means that in the worst case (when the system is probably already overloaded) 10 database queries are executed at half a second intervals for 5 seconds (per thread), a great way to further degrade performance. Poor thread pool usage - the&nbsp;getTransferInefficiently&nbsp;method is run from a static sized thread pool responsible for handling all requests queued for this process (typically between a few hundred and a few thousand per second). For each thread looping in this method there are numerous other requests that could have been processed instead. In the worst case if all threads are handling requests requiring this method then for a few seconds potentially thousands of requests will be queued unnecessarily. Poor transparency - under heavy load most of the invocations of the method will return null as the transfer object will not have been created and consequently can&#39;t be loaded in the timeout (despite adding significant load to the already strained system). There is also no mechanism for measuring the average time taken for the object to be created and no backoff policy to try and reduce server load. Solution The correct implementation to achieve the desired behaviour asynchronously is relatively simple. A separate process should register/subscribe to BOTransfer events, on successful transfer creation perform the processing currently performed on the object returned by the&nbsp;getTransferInefficiently&nbsp;method." />
<meta property="og:description" content="Few things are more irritating in software development than when people use a kludge rather than taking the time to implement a properly designed and robust solution. The peeve I am exercising today relates to the code snippet that follows:     private BOTransfer getTransferInefficiently(Trade trade) throws RemoteException {   // There is some delay between when a trade and corresponsing transfer is created   BOTransfer transfer = null; int cnt = 0; do {            try { Thread.sleep(500l);           } catch (Exception e) { return null;           }           transfer = getFirstTransfer(trade); } while (cnt++ &lt; 10 &amp;&amp; transfer == null); return transfer;     } The code is pretty simple. Wait 500ms and try and load a transfer object from the trade, repeat until the transfer object is loaded or the number of load attempts reaches 10. In a single threaded or single user environment this code might be excusable. In a multi-user production trading system processing hundreds of transactions a second this implementation is totally unacceptable. Some well meaning soul has added a comment further explaining the method: &nbsp; &nbsp; // This implementation is fundamentally broken in many ways. The transfer creation is &nbsp; &nbsp; // asynchronous and this logic should be triggered off the transfer creation event (instead of &nbsp; &nbsp; // looping and sleeping). This approach prevents this engine thread from processing any other &nbsp; &nbsp; // events and will not find the transfer in the case where the TransferEngine is under heavy &nbsp; &nbsp; // load. useInefficientWaitForTransfer method added to the interface to allow correct &nbsp; &nbsp; // implementation on new classes This person at least understood that the code was a problem and tried to mitigate the risks by extracting it into a separate method and adding the explanatory comment. Unfortunately for whatever reason (time constraints, lack of automated regression testing, indifference, ...) they only raised the visibility of the problem rather than fixing it entirely. Issues Increased system load - the call to getFirstTransfer actually does a remote call and a database query each time it is executed. This means that in the worst case (when the system is probably already overloaded) 10 database queries are executed at half a second intervals for 5 seconds (per thread), a great way to further degrade performance. Poor thread pool usage - the&nbsp;getTransferInefficiently&nbsp;method is run from a static sized thread pool responsible for handling all requests queued for this process (typically between a few hundred and a few thousand per second). For each thread looping in this method there are numerous other requests that could have been processed instead. In the worst case if all threads are handling requests requiring this method then for a few seconds potentially thousands of requests will be queued unnecessarily. Poor transparency - under heavy load most of the invocations of the method will return null as the transfer object will not have been created and consequently can&#39;t be loaded in the timeout (despite adding significant load to the already strained system). There is also no mechanism for measuring the average time taken for the object to be created and no backoff policy to try and reduce server load. Solution The correct implementation to achieve the desired behaviour asynchronously is relatively simple. A separate process should register/subscribe to BOTransfer events, on successful transfer creation perform the processing currently performed on the object returned by the&nbsp;getTransferInefficiently&nbsp;method." />
<link rel="canonical" href="http://localhost:4000/2013/03/26/missing-a-in-asynchronous-part-1.html" />
<meta property="og:url" content="http://localhost:4000/2013/03/26/missing-a-in-asynchronous-part-1.html" />
<meta property="og:site_name" content="Deplication" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-03-26T12:33:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Missing the A in Asynchronous - Part 1" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Craig Watcham"},"dateModified":"2013-03-26T12:33:00+00:00","datePublished":"2013-03-26T12:33:00+00:00","description":"Few things are more irritating in software development than when people use a kludge rather than taking the time to implement a properly designed and robust solution. The peeve I am exercising today relates to the code snippet that follows:     private BOTransfer getTransferInefficiently(Trade trade) throws RemoteException {   // There is some delay between when a trade and corresponsing transfer is created   BOTransfer transfer = null; int cnt = 0; do {            try { Thread.sleep(500l);           } catch (Exception e) { return null;           }           transfer = getFirstTransfer(trade); } while (cnt++ &lt; 10 &amp;&amp; transfer == null); return transfer;     } The code is pretty simple. Wait 500ms and try and load a transfer object from the trade, repeat until the transfer object is loaded or the number of load attempts reaches 10. In a single threaded or single user environment this code might be excusable. In a multi-user production trading system processing hundreds of transactions a second this implementation is totally unacceptable. Some well meaning soul has added a comment further explaining the method: &nbsp; &nbsp; // This implementation is fundamentally broken in many ways. The transfer creation is &nbsp; &nbsp; // asynchronous and this logic should be triggered off the transfer creation event (instead of &nbsp; &nbsp; // looping and sleeping). This approach prevents this engine thread from processing any other &nbsp; &nbsp; // events and will not find the transfer in the case where the TransferEngine is under heavy &nbsp; &nbsp; // load. useInefficientWaitForTransfer method added to the interface to allow correct &nbsp; &nbsp; // implementation on new classes This person at least understood that the code was a problem and tried to mitigate the risks by extracting it into a separate method and adding the explanatory comment. Unfortunately for whatever reason (time constraints, lack of automated regression testing, indifference, ...) they only raised the visibility of the problem rather than fixing it entirely. Issues Increased system load - the call to getFirstTransfer actually does a remote call and a database query each time it is executed. This means that in the worst case (when the system is probably already overloaded) 10 database queries are executed at half a second intervals for 5 seconds (per thread), a great way to further degrade performance. Poor thread pool usage - the&nbsp;getTransferInefficiently&nbsp;method is run from a static sized thread pool responsible for handling all requests queued for this process (typically between a few hundred and a few thousand per second). For each thread looping in this method there are numerous other requests that could have been processed instead. In the worst case if all threads are handling requests requiring this method then for a few seconds potentially thousands of requests will be queued unnecessarily. Poor transparency - under heavy load most of the invocations of the method will return null as the transfer object will not have been created and consequently can&#39;t be loaded in the timeout (despite adding significant load to the already strained system). There is also no mechanism for measuring the average time taken for the object to be created and no backoff policy to try and reduce server load. Solution The correct implementation to achieve the desired behaviour asynchronously is relatively simple. A separate process should register/subscribe to BOTransfer events, on successful transfer creation perform the processing currently performed on the object returned by the&nbsp;getTransferInefficiently&nbsp;method.","headline":"Missing the A in Asynchronous - Part 1","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2013/03/26/missing-a-in-asynchronous-part-1.html"},"url":"http://localhost:4000/2013/03/26/missing-a-in-asynchronous-part-1.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Deplication" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Deplication</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Missing the A in Asynchronous - Part 1</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-03-26T12:33:00+00:00" itemprop="datePublished">Mar 26, 2013
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Craig Watcham</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    Few things are more irritating in software development than when people use a&nbsp;<a href="http://en.wikipedia.org/wiki/Kludge">kludge</a>&nbsp;rather than taking the time to implement a properly designed and robust solution. The peeve I am exercising today relates to the code snippet that follows:<br />
<br />
<br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; <span style="color: #e06666;">private </span>BOTransfer getTransferInefficiently(Trade trade) <span style="color: #e06666;">throws </span>RemoteException {</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span style="white-space: pre;">&nbsp;   </span><span style="color: #6aa84f;">// There is some delay between when a trade and corresponsing transfer is created</span></span><br />
<span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;"><span style="white-space: pre;">&nbsp;   </span>BOTransfer transfer = </span><span style="color: #e06666; font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;">null</span><span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;">;</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">    </span><span style="color: #e06666;">int </span>cnt = 0;</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">        </span><span style="color: #e06666;">do </span>{</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;<span style="color: #e06666;">try </span>{</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">                </span>Thread.sleep(500l);</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; } <span style="color: #e06666;">catch</span> (Exception e) {</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">               </span><span style="color: #e06666;">return null</span>;</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;"> </span>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; transfer = getFirstTransfer(trade);</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">        </span>} <span style="color: #e06666;">while </span>(cnt++ &lt; 10 &amp;&amp; transfer == <span style="color: #e06666;">null</span>);</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;"><span class="Apple-tab-span" style="white-space: pre;">        </span><span style="color: #e06666;">return</span> transfer;</span><br />
<span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; }</span><br />
<div>
<br /></div>
<div>
The code is pretty simple. Wait 500ms and try and load a transfer object from the trade, repeat until the transfer object is loaded or the number of load attempts reaches 10. In a single threaded or single user environment this code might be excusable. In a multi-user production trading system processing hundreds of transactions a second this implementation is totally unacceptable. Some well meaning soul has added a comment further explaining the method:</div>
<div>
<br /></div>
<div>
<div>
<span style="color: #6aa84f; font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; // This implementation is fundamentally broken in many ways. The transfer creation is</span></div>
<div>
<span style="color: #6aa84f; font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; // asynchronous and this logic should be triggered off the transfer creation event (instead of</span></div>
<div>
<span style="color: #6aa84f; font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; // looping and sleeping). This approach prevents this engine thread from processing any other</span></div>
<div>
<span style="color: #6aa84f; font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; // events and will not find the transfer in the case where the TransferEngine is under heavy</span></div>
<div>
<span style="color: #6aa84f; font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; // load. useInefficientWaitForTransfer method added to the interface to allow correct</span></div>
<div>
<span style="color: #6aa84f; font-family: Helvetica Neue, Arial, Helvetica, sans-serif; font-size: x-small;">&nbsp; &nbsp; // implementation on new classes</span></div>
</div>
<div>
<br /></div>
<div>
This person at least understood that the code was a problem and tried to mitigate the risks by extracting it into a separate method and adding the explanatory comment. Unfortunately for whatever reason (time constraints, lack of automated regression testing, indifference, ...) they only raised the visibility of the problem rather than fixing it entirely.</div>
<div>
<br /></div>
<h4>
Issues</h4>
Increased system load - the call to&nbsp;<span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;">getFirstTransfer</span>&nbsp;actually does a remote call and a database query each time it is executed. This means that in the worst case (when the system is probably already overloaded) 10 database queries are executed at half a second intervals for 5 seconds (per thread), a great way to further degrade performance.<br />
<div>
<div>
<br /></div>
<div>
Poor thread pool usage - the&nbsp;<span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;">getTransferInefficiently</span>&nbsp;method is run from a static sized thread pool responsible for handling all requests queued for this process (typically between a few hundred and a few thousand per second). For each thread looping in this method there are numerous other requests that could have been processed instead. In the worst case if all threads are handling requests requiring this method then for a few seconds potentially thousands of requests will be queued unnecessarily.</div>
</div>
<div>
<br /></div>
<div>
Poor transparency - under heavy load most of the invocations of the method will return null as the transfer object will not have been created and consequently can't be loaded in the timeout (despite adding significant load to the already strained system). There is also no mechanism for measuring the average time taken for the object to be created and no backoff policy to try and reduce server load.<br />
<br />
<h4>
Solution</h4>
</div>
<div>
The correct implementation to achieve the desired behaviour asynchronously is relatively simple. A separate process should register/subscribe to BOTransfer events, on successful transfer creation perform the processing currently performed on the object returned by the&nbsp;<span style="font-family: 'Helvetica Neue', Arial, Helvetica, sans-serif; font-size: x-small;">getTransferInefficiently</span>&nbsp;method.</div>

  </div><a class="u-url" href="/2013/03/26/missing-a-in-asynchronous-part-1.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Deplication</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Deplication</li><li><a class="u-email" href="mailto:craig@deplication.net">craig@deplication.net</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/watchamcb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">watchamcb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Simpler is better.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
