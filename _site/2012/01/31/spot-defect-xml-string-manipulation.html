<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Spot the defect - XML string manipulation | Deplication</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="Spot the defect - XML string manipulation" />
<meta name="author" content="Craig Watcham" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="So I have been a bit lazy about posting recently, time to look at a defect found in some production code:             String details = XPathReader.getValueAt(detailPath, xml);             if (details != null &amp;&amp; details.length() &gt; 0) {                 String mappedDetails = getFormattedDetails(details, accId, pay);                 logger.info(“Details [” + details + “] replaced with [” + mappedDetails + “]”);                 xml = xml.replace(“Details=&quot;” + details + “&quot;”, “Details=&quot;” + mappedDetails + “&quot;”);             }             return xml; At first glance there is nothing particularly wrong with this code, the XPathReader class extracts a value from a specific path in the XML, some mapping is done on the value and the original value us replaced with the updated details. Unfortunately there is a sneaky defect in this code. The log message printed for the problematic input is: INFO  [MappingSessionBean] Details [Book##VALUE&amp;DEV] replaced with [Book VALUE 111111111] Take a moment to see if you are able to spot the problem… Not yet apparent? The input XML (with some details replaced): &lt;RequestXML xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”&gt;       &lt;Header Sending_System=”SOURCE” Message_Identifier=”Update”             Message_Status=”New” Message_Name=”Nostro Update” /&gt;       &lt;AccountingInfo BICCode=”XXXXXXXX” CurrencyCode=”USD”             TradingArea=”Book” Amount=”12345.67/NEW/11111111/444444.44”             ValueDate=”2011-11-11+0200” Details=”Book##VALUE&amp;amp;DEV”             TransactionReference=”111111111” AccountType=”PRINCIPAL” /&gt; &lt;/RequestXML&gt; Still not clear? Notice the difference between the input XML Details field and the log message? Details=&quot;Book##VALUE&amp;amp;DEV&quot;&nbsp; Details [Book##VALUE&amp;DEV] The Details value in the XML has the ampersand escaped as &quot;&amp;amp;&quot; while the call to XPathReader.getValueAt() returns the attribute value without the escaping. The getFormattedDetails method merrily goes about its job enriching the details string to be &quot;Book VALUE 111111111&quot; but then the code fails when trying to do the replace call: &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace(&quot;Details=\&quot;&quot; + details + &quot;\&quot;&quot;, &quot;Details=\&quot;&quot; + mappedDetails + &quot;\&quot;&quot;); The contents of the details variable are now &quot;Book##VALUE&amp;DEV&quot; instead of the original &quot;Book##VALUE&amp;amp;DEV&quot; so no replacement is performed. Given that this code is due to be replaced shortly the quick and easy fix is to use the Apache commons-lang StringEscapeUtils.escapeXml() method. Thus the replace call becomes: &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace(&quot;Details=\&quot;&quot; + StringEscapeUtils.escapeXml(details) + &quot;\&quot;&quot;, &quot;Details=\&quot;&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + StringEscapeUtils.escapeXml(mappedDetails) + &quot;\&quot;&quot;); The alternative (and more correct solution) would be to convert the XML to an object using your favourite XML library and then perform the data manipulation on the object before converting back to XML." />
<meta property="og:description" content="So I have been a bit lazy about posting recently, time to look at a defect found in some production code:             String details = XPathReader.getValueAt(detailPath, xml);             if (details != null &amp;&amp; details.length() &gt; 0) {                 String mappedDetails = getFormattedDetails(details, accId, pay);                 logger.info(“Details [” + details + “] replaced with [” + mappedDetails + “]”);                 xml = xml.replace(“Details=&quot;” + details + “&quot;”, “Details=&quot;” + mappedDetails + “&quot;”);             }             return xml; At first glance there is nothing particularly wrong with this code, the XPathReader class extracts a value from a specific path in the XML, some mapping is done on the value and the original value us replaced with the updated details. Unfortunately there is a sneaky defect in this code. The log message printed for the problematic input is: INFO  [MappingSessionBean] Details [Book##VALUE&amp;DEV] replaced with [Book VALUE 111111111] Take a moment to see if you are able to spot the problem… Not yet apparent? The input XML (with some details replaced): &lt;RequestXML xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”&gt;       &lt;Header Sending_System=”SOURCE” Message_Identifier=”Update”             Message_Status=”New” Message_Name=”Nostro Update” /&gt;       &lt;AccountingInfo BICCode=”XXXXXXXX” CurrencyCode=”USD”             TradingArea=”Book” Amount=”12345.67/NEW/11111111/444444.44”             ValueDate=”2011-11-11+0200” Details=”Book##VALUE&amp;amp;DEV”             TransactionReference=”111111111” AccountType=”PRINCIPAL” /&gt; &lt;/RequestXML&gt; Still not clear? Notice the difference between the input XML Details field and the log message? Details=&quot;Book##VALUE&amp;amp;DEV&quot;&nbsp; Details [Book##VALUE&amp;DEV] The Details value in the XML has the ampersand escaped as &quot;&amp;amp;&quot; while the call to XPathReader.getValueAt() returns the attribute value without the escaping. The getFormattedDetails method merrily goes about its job enriching the details string to be &quot;Book VALUE 111111111&quot; but then the code fails when trying to do the replace call: &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace(&quot;Details=\&quot;&quot; + details + &quot;\&quot;&quot;, &quot;Details=\&quot;&quot; + mappedDetails + &quot;\&quot;&quot;); The contents of the details variable are now &quot;Book##VALUE&amp;DEV&quot; instead of the original &quot;Book##VALUE&amp;amp;DEV&quot; so no replacement is performed. Given that this code is due to be replaced shortly the quick and easy fix is to use the Apache commons-lang StringEscapeUtils.escapeXml() method. Thus the replace call becomes: &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace(&quot;Details=\&quot;&quot; + StringEscapeUtils.escapeXml(details) + &quot;\&quot;&quot;, &quot;Details=\&quot;&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + StringEscapeUtils.escapeXml(mappedDetails) + &quot;\&quot;&quot;); The alternative (and more correct solution) would be to convert the XML to an object using your favourite XML library and then perform the data manipulation on the object before converting back to XML." />
<link rel="canonical" href="http://localhost:4000/2012/01/31/spot-defect-xml-string-manipulation.html" />
<meta property="og:url" content="http://localhost:4000/2012/01/31/spot-defect-xml-string-manipulation.html" />
<meta property="og:site_name" content="Deplication" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2012-01-31T05:56:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Spot the defect - XML string manipulation" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Craig Watcham"},"dateModified":"2012-01-31T05:56:00+00:00","datePublished":"2012-01-31T05:56:00+00:00","description":"So I have been a bit lazy about posting recently, time to look at a defect found in some production code:             String details = XPathReader.getValueAt(detailPath, xml);             if (details != null &amp;&amp; details.length() &gt; 0) {                 String mappedDetails = getFormattedDetails(details, accId, pay);                 logger.info(“Details [” + details + “] replaced with [” + mappedDetails + “]”);                 xml = xml.replace(“Details=&quot;” + details + “&quot;”, “Details=&quot;” + mappedDetails + “&quot;”);             }             return xml; At first glance there is nothing particularly wrong with this code, the XPathReader class extracts a value from a specific path in the XML, some mapping is done on the value and the original value us replaced with the updated details. Unfortunately there is a sneaky defect in this code. The log message printed for the problematic input is: INFO  [MappingSessionBean] Details [Book##VALUE&amp;DEV] replaced with [Book VALUE 111111111] Take a moment to see if you are able to spot the problem… Not yet apparent? The input XML (with some details replaced): &lt;RequestXML xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance”&gt;       &lt;Header Sending_System=”SOURCE” Message_Identifier=”Update”             Message_Status=”New” Message_Name=”Nostro Update” /&gt;       &lt;AccountingInfo BICCode=”XXXXXXXX” CurrencyCode=”USD”             TradingArea=”Book” Amount=”12345.67/NEW/11111111/444444.44”             ValueDate=”2011-11-11+0200” Details=”Book##VALUE&amp;amp;DEV”             TransactionReference=”111111111” AccountType=”PRINCIPAL” /&gt; &lt;/RequestXML&gt; Still not clear? Notice the difference between the input XML Details field and the log message? Details=&quot;Book##VALUE&amp;amp;DEV&quot;&nbsp; Details [Book##VALUE&amp;DEV] The Details value in the XML has the ampersand escaped as &quot;&amp;amp;&quot; while the call to XPathReader.getValueAt() returns the attribute value without the escaping. The getFormattedDetails method merrily goes about its job enriching the details string to be &quot;Book VALUE 111111111&quot; but then the code fails when trying to do the replace call: &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace(&quot;Details=\\&quot;&quot; + details + &quot;\\&quot;&quot;, &quot;Details=\\&quot;&quot; + mappedDetails + &quot;\\&quot;&quot;); The contents of the details variable are now &quot;Book##VALUE&amp;DEV&quot; instead of the original &quot;Book##VALUE&amp;amp;DEV&quot; so no replacement is performed. Given that this code is due to be replaced shortly the quick and easy fix is to use the Apache commons-lang StringEscapeUtils.escapeXml() method. Thus the replace call becomes: &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace(&quot;Details=\\&quot;&quot; + StringEscapeUtils.escapeXml(details) + &quot;\\&quot;&quot;, &quot;Details=\\&quot;&quot;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + StringEscapeUtils.escapeXml(mappedDetails) + &quot;\\&quot;&quot;); The alternative (and more correct solution) would be to convert the XML to an object using your favourite XML library and then perform the data manipulation on the object before converting back to XML.","headline":"Spot the defect - XML string manipulation","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2012/01/31/spot-defect-xml-string-manipulation.html"},"url":"http://localhost:4000/2012/01/31/spot-defect-xml-string-manipulation.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Deplication" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Deplication</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Spot the defect - XML string manipulation</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2012-01-31T05:56:00+00:00" itemprop="datePublished">Jan 31, 2012
      </time>• <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">Craig Watcham</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    So I have been a bit lazy about posting recently, time to look at a defect found in some production code:<br />
<br />
<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String details = XPathReader.getValueAt(detailPath, xml);<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (details != null &amp;&amp; details.length() &gt; 0) {<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; String mappedDetails = getFormattedDetails(details, accId, pay);<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; logger.info("Details [" + details + "] replaced with [" + mappedDetails + "]");<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace("Details=\"" + details + "\"", "Details=\"" + mappedDetails + "\"");<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return xml;<br />
<br />
At first glance there is nothing particularly wrong with this code, the XPathReader class extracts a value from a specific path in the XML, some mapping is done on the value and the original value us replaced with the updated details. Unfortunately there is a sneaky defect in this code. The log message printed for the problematic input is:<br />
<br />
INFO &nbsp;[MappingSessionBean] Details [Book##VALUE&amp;DEV] replaced with [Book VALUE 111111111]<br />
<br />
Take a moment to see if you are able to spot the problem... Not yet apparent? The input XML (with some details replaced):<br />
<br />
<br />
&lt;RequestXML xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;<br />
&nbsp; &nbsp; &nbsp; &lt;Header Sending_System="SOURCE" Message_Identifier="Update"<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Message_Status="New" Message_Name="Nostro Update" /&gt;<br />
&nbsp; &nbsp; &nbsp; &lt;AccountingInfo BICCode="XXXXXXXX" CurrencyCode="USD"<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TradingArea="Book" Amount="12345.67/NEW/11111111/444444.44"<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ValueDate="2011-11-11+0200" Details="Book##VALUE&amp;amp;DEV"<br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TransactionReference="111111111" AccountType="PRINCIPAL" /&gt;<br />
&lt;/RequestXML&gt;<br />
<br />
<div><br />
</div><div>Still not clear? Notice the difference between the input XML Details field and the log message?</div><div><br />
</div><div>Details="Book##VALUE&amp;amp;DEV"&nbsp;</div><div>Details [Book##VALUE&amp;DEV]</div><div><br />
</div><div><div>The Details value in the XML has the ampersand escaped as "&amp;amp;" while the call to XPathReader.getValueAt() returns the attribute value without the escaping. The getFormattedDetails method merrily goes about its job enriching the details string to be "Book VALUE 111111111" but then the code fails when trying to do the replace call:</div><div><br />
</div><div>&nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace("Details=\"" + details + "\"", "Details=\"" + mappedDetails + "\"");</div><div><br />
</div><div>The contents of the details variable are now "Book##VALUE&amp;DEV" instead of the original "Book##VALUE&amp;amp;DEV" so no replacement is performed. Given that this code is due to be replaced shortly the quick and easy fix is to use the Apache commons-lang StringEscapeUtils.escapeXml() method. Thus the replace call becomes:</div><div><br />
</div><div>&nbsp; &nbsp; &nbsp; &nbsp; xml = xml.replace("Details=\"" + StringEscapeUtils.escapeXml(details) + "\"", "Details=\""</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; + StringEscapeUtils.escapeXml(mappedDetails) + "\"");</div><div><br />
</div><div>The alternative (and more correct solution) would be to convert the XML to an object using your favourite XML library and then perform the data manipulation on the object before converting back to XML.</div></div>
  </div><a class="u-url" href="/2012/01/31/spot-defect-xml-string-manipulation.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Deplication</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Deplication</li><li><a class="u-email" href="mailto:craig@deplication.net">craig@deplication.net</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/watchamcb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">watchamcb</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Simpler is better.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
